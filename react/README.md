# React Contents


## 리액트란?
리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는데 사용합니다. 구조가 MVC, MVW 등인 프레임워크와 달리, 오직 V(View)만 신경 쓰는 라이브러리입니다.

리액트 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체를 컴포넌트(component)라고 합니다. 컴포넌트는 재사용이 가능한 API로 수많은 기능들을 내장하고 있으며, 
컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의합니다.

사용자 화면에 뷰를 보여 주는 것을 렌더링이라고 하는데 리액트는 데이터가 변할 때마다 새롭게 리렌더링하면서 성능을 아끼고, 최적의 사용자 경험을 제공합니다.
<br><br>

### 리액트 렌더링
리액트에서는 render() { ... } 함수를 이용해서 컴포넌트가 어떻게 생겼는지 정의하는 역할을 합니다. 뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 가진 객체를 반환합니다.

컴포넌트 내부에는 또 다른 컴포넌트들이 들어갈 수 있으며, 이때 render 함수를 실행하면 내부에 있는 컴포넌트들도 재귀적으로 렌더링합니다.

컴포넌트들의 렌더링이 끝나면 지니고 있는 정보들로 HTML 마크업을 만들어서 DOM 요소 안에 주입합니다.

리액트에서 뷰를 업데이트할 때도 render() { ... } 함수를 이용해서 합니다. 새로운 데이터를 가지고 render 함수를 호출해서 만든 컴포넌트와 기존에 render 함수로 만튼 컴포넌트 정보를
비교합니다. 사바스크립트를 사용하여 두 가지 뷰를 최소한의 연산으로 비교한 후, 둘의 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트 합니다.
<br><br>

### Virtual DOM
리액트의 주요 틍징 중 하나는 Virtual DOM을 사용하는 것입니다.
Virtual DOM을 사용하면 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용합니다.
리엑트에서 Virtual DOM 데이터 업데이트 절차
1. 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링
2. 이전 Virtual DOM의 내용과 현재 내용을 비교
3. 바뀐 부분만 실제 DOM에 적용
<br><br>

### 클래스형 컴포넌트와 함수형 컴포넌트의 차이점
1.클래스형 컴포넌트
- LifeCycle API와 state 기능 사용 가능
- 임의의 메서드 정의 가능

2.함수형 컴포넌트
- React v16.8 이후 hook을 통해 LifeCycle API와 state 기능 사용 가능
- 클래스형 컴포넌트보다 선언하기 간편
- 클래스형 컴포넌트보다 메모리 자원을 덜 사용
- 빌드 파일의 크기가 클래스형 컴포넌트보다 작음

이외에도 기본 구조, state 사용법, props 전달받는 법, LifeCycle method 등 여러 가지 차이점이 있습니다.

### 리액트 장단점
1.장점
- Virtual DOM 사용으로 빠른 렌더링 가능
- UI 수정과 재사용성이 높으며, 유지보수 용이
- 공식문서 및 자료가 많아 생태계가 넓음
- 뛰어난 Garbage Collection, 메모리 관리, 성능을 가짐
- CSR SSR 모두 지원
- 단방향 데이터 바인딩을 통한 디버깅이 용이하고 안정성이 높음
- 리액트는 라이브러리이기 때문에 다른 프레임워크나 라이브러리와 혼용 가능

2.단점
- IE8 이하 버전은 지원하지 않음
- 진입장벽이 있음
- view만 담당하기 때문에 라우팅, ajax처리, 상태관리 등등은 직접 구현해야 함함
<br><br>

## DOM이란?
Document Object Model의 약어입니다. 즉, 객체로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성합니다.
웹 브라우저는 DOM을 활용하여 객체에 자바스크립트와 CSS를 적용하고 DOM은 트리 형태라 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입도 가능합니다.
![image](https://user-images.githubusercontent.com/78462110/221190944-281630e7-b989-4a17-88a8-3e5ced430287.png)

<br><br>

### DOM의 문제점
DOM의 문제점은 동적 UI에 최적화 되어 있지 않다는 것입니다. HTML은 자체적으로 정적이지만 자바스크립트를 사용하여 동적으로 만들 수 있습니다.
DOM 자체는 빠르지만 규모가 큰 웹 애플리케이션에서 DOM에 직접 접근하여 변화를 주다 보면 성능 이슈가 조금씩 발생할 수 있습니다. 
이유는 웹 브라우저 단에서 DOM에 변화가 일어나면 웹 브라우저가 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트 하는 과정에서 컴퓨터 자원을 사용해서 웹 페이지를 새로 그리기 때문입니다.

리액트는 Virtual DOM 방식을 사용하여 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행합니다.
<br><br>

## JSX란?
JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼습니다. JSX는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됩니다.

```javascript
// JSX
function App() {
  return(
    <div>
      Hello <b>react</b>
    </div>
   );
}

// 바벨이 Javascript 코드로 변환
function App() {
  return React.createElement("div", null, "Hello ", React.createElement("b", null, "react"))
```
<br><br>

### FLUX
FLUX는 라이브러리나 프레임워크가 아닌 추상적인 개념입니다.
MVC 패턴에서 쌍방향적인 데이터 흐름을 강조했던 것과 달리 FLUX 패턴에서는 단방향 데이터 흐름을 강조합니다.

MVC 패턴의 경우 사용자의 액션이 있을때 이를 바탕으로 설계된 컨트롤러를 통해 모델을 변화하고 이를 뷰에 반영합니다.
- 보여져야할 뷰가 적거나, 변경될 모델이 적은 경우 효율적
- 모델과 뷰가 복잡하게 얽혀 있으면 어떤 모델이 변경되어 뷰가 변경되었는지 제대로 확인 불가능

FLUX 패턴의 경우 사용자의 액션은 디스패처에 의해 통제됩니다. 디스패처가 스토어를 업데이트하고 변경된 스토어에 대한 뷰를 리렌더링합니다.
뷰에서는 스토어에 직접 접근하지 않으며, 디스패처로 다시 액션을 보내고 스토어를 업데이트한뒤, 다시 뷰를 리렌더링하는 단방향적인 구조를 가집니다.
<br><br>

## 리덕스란?
리덕스는 상태관리 라이브러리 중 하나로 여러 가지 상태관리 라이브러리 중 가장 많이 사용되고 있습니다.
리덕스는 Store라는 변수를 이용하여 전역 상태관리를 하게 됩니다.
<br><br>

### 리덕스의 기본 원칙
1. 응용 프로그램의 전역상태는 단일 저장소 내의 트리에 저장됩니다.
2. state는 읽기 전용입니다.
3. 순수 함수에 의해서 변경되어야 합니다.
<br><br>

### React에서 state 불변성을 유지해야한다는 말의 의미
객체는 실제 데이터 값이 아닌 참조 값을 가집니다. 그렇기 때문에 복사하여 동일한 참조 값을 가지는 객체 중 하나라도 변경된다면, 모든 객체의 내부 값이 변경될 것입니다.

`...연산자` 를 통해 복사할 경우 A와 B는 값은 값을 가지더라도 새로운 객체를 할당 받은 상태가 됩니다. 따라서 A와 B 내부의 값은 같더라도 참조하는 객체가 다르기 때문에 무결성을 유지할수 있습니다.

리액트에서는 데이터를 저장할 때 객체 형식 또는 배열 형식의 데이터를 많이 다루게 되는데, 원본 배열이 변경되는 경우 의도한 동작과 다르게 동작할 수 있으며, 어떤 함수에 의해 부수효과(side effect)가 발생했는지 찾기 어려울 수 있습니다.

```javascript
let A = {
  name: "junhee",
  age: 25,
  job: "student",
};

B = { ...A };

console.log("A", A);
console.log("B", B);
/*
A { name: 'junhee', age: 25, job: 'student' }
B { name: 'junhee', age: 25, job: 'student' }
*/

B = { ...A, job: "frontend developer" };

console.log("A", A);
console.log("B", B);

/*
A { name: 'junhee', age: 25, job: 'student' }
B { name: 'junhee', age: 25, job: 'frontend developer' }
*/
```
<br><br>

### 리듀서 내부에서 불변성을 지키는 이유? 전개 연산자의 단점을 해결할 수 있는 방법
컴포넌트는 4가지의 경우에 업데이트합니다.
- props가 바뀔 때
- state가 바뀔 때
- 부모 컴포넌트가 리렌더링될 때
- this.forceUpdate로 강제로 렌더링을 트리거할 때

리듀서의 initial state에는 서버에서 넘겨받는 정보를 저장하고 전역으로 해당 객체를 사용할 수 있는 저장소 역할을 합니다.

불변성을 지킴으로써 각각의 고유한 참조값을 가지는 객체를 복사해서 사용함으로써 어떤 함수가 호출됐을 때 같은 객체를 참조한다면 생길 수 있는 불필요한 리렌더링과 부수효과를 줄일 수 있습니다.

하지만 `...spread` 연산자를 사용하여 객체를 복사해 사용할 경우 객체의 깊이에 따라, 로직 구성이 매우 어려울 수 있습니다.

```javascript
const nextState = {
  ...state,
  posts: state.posts.map((post) =>
    post.id === 1
      ? {
          ...post,
          comments: post.comments.concat({
            id: 3,
            text: "새로운 댓글",
          }),
        }
      : post
  ),
};
```
이를 해결하기 위해 등장한 라이브러리가 `immer` 라이브러리입니다.
`produce`, `draft` 라는 키워드를 사용해서 기존의 `...spread` 연산자를 사용하지 않고도 불변성을 유지해주면 불필요한 부수효과(side effect)를 막아줍니다.

```javascript
const nextState = produce(state, (draft) => {
  const post = draft.posts.find((post) => post.id === 1);
  post.comments.push({
    id: 3,
    text: "와 정말 쉽다!",
  });
});
```

